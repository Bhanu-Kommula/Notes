SYSTEM OVERVIEW 

You are building a backend system for a school admin panel.
The admin wants to:

        Add new students
        View all students
        Get student by name
        Update marks
        Delete student by name

These requests will come from frontend via HTTP ‚Üí you will expose REST APIs ‚Üí store/fetch data from Oracle DB.

HOW WE STRUCTURE THE PROJECT 

              com.myprojects.studentmgmt
              ‚îÇ
              ‚îú‚îÄ‚îÄ controller         ‚Üí REST layer (APIs)
              ‚îú‚îÄ‚îÄ service            ‚Üí Business logic
              ‚îú‚îÄ‚îÄ repository         ‚Üí DB operations
              ‚îú‚îÄ‚îÄ dto                ‚Üí Request/response objects
              ‚îú‚îÄ‚îÄ entity             ‚Üí Maps to DB table
              ‚îú‚îÄ‚îÄ exception          ‚Üí Global exception handling
              ‚îú‚îÄ‚îÄ config             ‚Üí Swagger & log configs
              ‚îî‚îÄ‚îÄ application.properties


STEP 1: StudentEntity
üîç Why?

      It maps our Java class to the DB table
      JPA uses it to persist and fetch data
      Real apps never use raw SQL directly ‚Äî always through entities

StudentEntity.java

           package com.myprojects.studentmgmt.entity;
      
      // These annotations help reduce boilerplate code (getters, setters, constructors)
      import lombok.Data;
      import lombok.NoArgsConstructor;
      import lombok.AllArgsConstructor;
      
      import jakarta.persistence.*; // JPA annotations to map this class to a DB table
      
      /**
       * This class represents the "studentsinfo" table in the database.
       * Each object of this class will be a row in that table.
       */
      @Entity  // Tells JPA this class is an Entity (linked to DB table)
      @Table(name = "studentsinfo")  // Specifies the table name in the DB
      @Data  // Lombok annotation to auto-generate getters/setters/toString/hashCode
      @NoArgsConstructor  // Generates default no-arg constructor
      @AllArgsConstructor  // Generates constructor with all fields
      public class StudentEntity {
      
          /**
           * The primary key column in the database.
           * It's autogenerated by Oracle using identity strategy.
           * You don't need to set this manually ‚Äî JPA will handle it.
           */
          @Id  // Marks this field as the primary key
          @GeneratedValue(strategy = GenerationType.IDENTITY)  // Auto-generates unique IDs
          private Long id;
      
          /**
           * Student's full name.
           * We'll still allow searching students by name in our APIs.
           */
          private String name;
      
          /**
           * Age of the student (e.g., 18, 21)
           */
          private Integer age;
      
          /**
           * City of the student (e.g., Hyderabad, Dallas)
           */
          private String city;
      
          /**
           * Country of the student (e.g., India, USA)
           */
          private String country;
      
          /**
           * Marks in Maths subject (0-100 range)
           */
          private Integer maths;
      
          /**
           * Marks in Physics subject
           */
          private Integer physics;
      
          /**
           * Marks in Chemistry subject
           */
          private Integer chemistry;
      }



STEP 2: StudentDTO.java

Create a data transfer object that:

    Takes input from frontend (JSON)
    Validates it properly (age can't be negative, name can't be blank, etc.)
    Keeps Entity safe from external exposure
    
Why Do We Use DTO in Real-Time?
We never expose entity classes directly to the frontend.

Entity might contain sensitive fields (like password or ID) that should never leave backend.

DTO gives us full control over:

      What we accept
      What we expose
      What we validate

                package com.myprojects.studentmgmt.dto;
                
                // Lombok to reduce boilerplate code
                import lombok.Data;
                import lombok.NoArgsConstructor;
                import lombok.AllArgsConstructor;
                
                // Validation annotations
                import jakarta.validation.constraints.*;
                
                @Data  // Generates getters/setters/toString/hashCode
                @NoArgsConstructor  // No-argument constructor required for frameworks
                @AllArgsConstructor  // All-argument constructor for easy mapping
                public class StudentDTO {

    /**
     * Student name must not be blank or null.
     * This is a required field in most real apps.
     */
    @NotBlank(message = "Name is required")
    private String name;

    /**
     * Age should be >= 1.
     * 0 or negative ages are not valid.
     */
    @Min(value = 1, message = "Age must be at least 1")
    private Integer age;

    /**
     * City must not be blank.
     * Even in dropdown forms, we should validate this.
     */
    @NotBlank(message = "City is required")
    private String city;

    /**
     * Country must not be blank.
     * Required to know the student's region.
     */
    @NotBlank(message = "Country is required")
    private String country;

    /**
     * Maths marks: minimum 0, max 100.
     * Common real-world validation for exams.
     */
    @Min(value = 0, message = "Maths must be at least 0")
    @Max(value = 100, message = "Maths can't exceed 100")
    private Integer maths;

    @Min(value = 0, message = "Physics must be at least 0")
    @Max(value = 100, message = "Physics can't exceed 100")
    private Integer physics;

    @Min(value = 0, message = "Chemistry must be at least 0")
    @Max(value = 100, message = "Chemistry can't exceed 100")
    private Integer chemistry;
    }


Why We don‚Äôt include id in the DTO (for input)

The StudentDTO we created is for input ‚Äî the request that comes from frontend.
In POST /students API, frontend should NOT provide an ID.
We tell Spring JPA to autogenerate it, using:

        @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

But how do we return id in the response?

Create a ResponseDTO that includes id
This is what most real-world projects do.


    Why We Use a Separate StudentResponseDTO?
    We don‚Äôt want to send entire entity to frontend (good security and design practice).
    StudentDTO is only for receiving input (it doesn't have id)
    StudentResponseDTO is for returning student data, including the auto-generated ID after saving to DB. 


StudentResponseDTO.java 

      package com.myprojects.studentmgmt.dto;
      
      // Lombok reduces boilerplate like getters/setters
      import lombok.Data;
      import lombok.NoArgsConstructor;
      import lombok.AllArgsConstructor;
      
      /**
       * This DTO is used only for sending student data back to the frontend.
       * It includes the auto-generated ID, which is created after the student is saved.
       */
      @Data  // Generates getters, setters, toString, equals, hashCode
      @NoArgsConstructor  // Needed for frameworks like Jackson
      @AllArgsConstructor  // Helpful for converting Entity ‚Üí DTO easily
      public class StudentResponseDTO {
      
          /**
           * This is the student's unique identifier.
           * It‚Äôs generated by the database (Oracle) during save.
           * We include it in the response so frontend can track the student.
           */
          private Long id;
      
          /**
           * Student's full name
           */
          private String name;
      
          /**
           * Student's age
           */
          private Integer age;
      
          /**
           * City where the student lives
           */
          private String city;
      
          /**
           * Country of residence
           */
          private String country;
      
          /**
           * Marks in Maths
           */
          private Integer maths;
      
          /**
           * Marks in Physics
           */
          private Integer physics;
      
          /**
           * Marks in Chemistry
           */
          private Integer chemistry;
      }


STEP 3: StudentRepository.java

Why We Use a Repository?
This is the DB layer of your backend

We use Spring Data JPA, which auto-generates DB queries like:

      save()
      
      findAll()
      
      findById()
      
      findByName()
      
      deleteByName()

‚úÖ We don‚Äôt write SQL manually here ‚Äî JPA does it for us based on method names.


‚úÖ StudentRepository.java (Fully Explained)
      
      
      package com.myprojects.studentmgmt.repository;
      
      import com.myprojects.studentmgmt.entity.StudentEntity;
      import org.springframework.data.jpa.repository.JpaRepository;
      import org.springframework.stereotype.Repository;
      
      import java.util.Optional;
      import java.util.List;
      
      /**
       * This interface is used to interact with the database.
       * Spring Data JPA will automatically implement all required logic based on method names.
       */
      @Repository  // Optional but makes it clear this is a Spring-managed DB bean
      public interface StudentRepository extends JpaRepository<StudentEntity, Long> {
          
          /**
           * Custom method to find a student by their name.
           * Spring will convert this into a SQL query automatically:
           * SELECT * FROM studentsinfo WHERE name = ?
           */
          Optional<StudentEntity> findByName(String name);
      
          /**
           * Custom method to delete a student by their name.
           * DELETE FROM studentsinfo WHERE name = ?
           */
          void deleteByName(String name);
      
          /**
           * (Optional) You can also return multiple students by name (in case of duplicates)
           * SELECT * FROM studentsinfo WHERE name = ?
           */
          List<StudentEntity> findAllByName(String name);
      }



JpaRepository<StudentEntity, Long>
What is it?
This is a Spring Data JPA interface that:

Provides built-in database operations

      Automatically implements everything like save(), findById(), deleteById() without us writing SQL or logic

Why do we pass <StudentEntity, Long>?
StudentEntity ‚Üí The class that maps to DB (@Entity)

Long ‚Üí The type of the primary key (id)

So now, just by extending JpaRepository, you get:

      save(entity);       // INSERT or UPDATE
      findById(id);       // SELECT * FROM table WHERE id = ?
      deleteById(id);     // DELETE FROM table WHERE id = ?
      findAll();          // SELECT * FROM table
üëâ No need to write SQL. JPA handles it for you.


Optional<StudentEntity> findByName(String name)
üîç What is Optional?

This is a class from Java 8 ‚Äî it‚Äôs like a wrapper around a value that may or may not exist.
 It helps avoid NullPointerException.

        Optional<StudentEntity> student = studentRepo.findByName("Bhanu");

What is Optional?
Optional<T> is a container object introduced in Java 8 that may or may not contain a non-null value.

It's like a box:

If there‚Äôs something inside ‚Üí it has a value

If it‚Äôs empty ‚Üí it means the value is not present

‚úÖ Main purpose: To avoid NullPointerException and write more readable, null-safe code.

üî∑ 2. üß† Why was Optional introduced?
Earlier, we wrote code like:

      
      String name = user.getName();
      if (name != null) {
          System.out.println(name.toUpperCase());
      }
We had to manually check for null to avoid crashes. Optional solves this by making absence of value explicit, not hidden.

üî∑ 3. ‚úÖ Real-World Analogy
Imagine you're waiting for a delivery:

      If package arrives ‚Üí you open it.
      
      If no delivery ‚Üí you move on.
      
      Same with Optional:
      
      If value is present ‚Üí process it.
      
      If not ‚Üí define fallback behavior.

üî∑ 4. ‚úÖ How to Create Optional

// a. Empty Optional
Optional<String> empty = Optional.empty();

// b. Non-null value (throws exception if null passed)
Optional<String> name = Optional.of("Bhanu");

// c. Nullable value (safe)
Optional<String> nickname = Optional.ofNullable(null);
üî∑ 5. üì¶ Useful Methods of Optional
üî∏ isPresent() / isEmpty()

if (nickname.isPresent()) {
    System.out.println("Name: " + nickname.get());
}
üî∏ get()
Returns the value if present, throws NoSuchElementException if not.


String actualName = name.get();  // Be careful! Use only if sure value is present.
‚úÖ Better: use ifPresent() or orElse() to be safe.

üî∏ ifPresent()
Executes the lambda only if value is present.


name.ifPresent(n -> System.out.println(n.toUpperCase()));
üî∏ orElse(), orElseGet(), orElseThrow()

String defaultName = nickname.orElse("Default Name");

String defaultNameLazy = nickname.orElseGet(() -> "Lazy Name"); // Better for performance

String mustBeThere = nickname.orElseThrow(() -> new RuntimeException("Name is missing!"));
üî∏ map() and flatMap()
Used to transform the value if present:

    
    Optional<String> upperCaseName = name.map(String::toUpperCase);
    For example, if you have Optional<User>, and inside it, you want getAddress():
    
          
      Optional<String> city = userOptional
          .flatMap(User::getAddress)
          .map(Address::getCity);


indByName(String name) ‚Äî Custom Method
üîç Why This Works?
Because of Spring Data JPA method naming convention:

You can define methods like:

        findByName()
        
        findByAgeGreaterThan()
        
        findByCityAndCountry()
        
        And JPA will:
        
        Parse the method name
        
        Build the query

Run it automatically

    üìå Example Mappings:
    Method Name	Generated SQL
    findByName("Bhanu")	SELECT * FROM studentsinfo WHERE name = 'Bhanu'
    deleteByName("Bhanu")	DELETE FROM studentsinfo WHERE name = 'Bhanu'
    findByAgeGreaterThan(20)	SELECT * FROM studentsinfo WHERE age > 20
    
    ‚úÖ No need to write @Query unless you want custom JPQL or native SQL.

üß† Summary Table
Concept	What You Learned
JpaRepository	Interface that gives DB access methods without SQL
Optional<T>	Wrapper to safely handle null values
Custom Queries	You can write findBy... and JPA will generate SQL
Delete Methods	You can write deleteBy... and JPA will generate DELETE queries


STEP 4: Service Layer (StudentService + StudentServiceImpl)
üéØ Goal:
Handle business logic (example: total marks, validations, decision-making)

Connect Controller ‚Üí Repository

Keep code clean, testable, and future-proof

In real projects, Controller should never directly call Repository ‚Äî Service acts as the middleman with brains üß†.

üîß Structure:
StudentService.java ‚Üí Interface (declares what should be done)

StudentServiceImpl.java ‚Üí Actual implementation of those methods

Why this 2-class setup?
üß† Real-time companies do this to allow easy testing, mocking, swapping, and scaling logic.

‚úÖ 1. StudentService.java (Interface with method declarations)

        
        package com.myprojects.studentmgmt.service;
        
        import com.myprojects.studentmgmt.dto.StudentDTO;
        import com.myprojects.studentmgmt.dto.StudentResponseDTO;
        
        import java.util.List;
        
        /**
         * This is the service interface that defines what operations the student service should support.
         * Implementation will be provided in StudentServiceImpl.
         */
        public interface StudentService {
        
            // Save a new student and return the response DTO with generated ID
            StudentResponseDTO save(StudentDTO studentDTO);
        
            // Fetch all students from DB and return as list of response DTOs
            List<StudentResponseDTO> getAll();
        
            // Get a single student by name
            StudentResponseDTO getByName(String name);
        
            // Update marks for a student
            StudentResponseDTO updateMarks(String name, int maths, int physics, int chemistry);
        
            // Delete a student by name
            String deleteByName(String name);
        
            // Get total marks by student name
            int getTotalMarksByName(String name);
        }


  2. StudentServiceImpl.java (Actual implementation)




            package com.myprojects.studentmgmt.service;
            
            import com.myprojects.studentmgmt.dto.StudentDTO;
            import com.myprojects.studentmgmt.dto.StudentResponseDTO;
            import com.myprojects.studentmgmt.entity.StudentEntity;
            import com.myprojects.studentmgmt.repository.StudentRepository;
            import org.springframework.beans.factory.annotation.Autowired;
            import org.springframework.stereotype.Service;
            
            import java.util.List;
            import java.util.stream.Collectors;
            
            /**
             * This is the implementation of StudentService.
             * It handles business logic and talks to the repository.
             */
            @Service  // Marks this as a Spring service bean
            public class StudentServiceImpl implements StudentService {
            
            @Autowired
            private StudentRepository studentRepository;
        
            /**
             * Save a new student.
             * Convert DTO ‚Üí Entity, save, then convert Entity ‚Üí ResponseDTO.
             */
            @Override
            public StudentResponseDTO save(StudentDTO dto) {
                // Convert DTO to Entity
                StudentEntity student = new StudentEntity();
                student.setName(dto.getName());
                student.setAge(dto.getAge());
                student.setCity(dto.getCity());
                student.setCountry(dto.getCountry());
                student.setMaths(dto.getMaths());
                student.setPhysics(dto.getPhysics());
                student.setChemistry(dto.getChemistry());
        
                // Save to DB (JPA will generate ID here)
                StudentEntity saved = studentRepository.save(student);
        
                // Convert Entity back to ResponseDTO
                return new StudentResponseDTO(
                    saved.getId(),
                    saved.getName(),
                    saved.getAge(),
                    saved.getCity(),
                    saved.getCountry(),
                    saved.getMaths(),
                    saved.getPhysics(),
                    saved.getChemistry()
                );
            }
        
            /**
             * Fetch all students and convert them to response DTOs.
             */
            @Override
            public List<StudentResponseDTO> getAll() {
                return studentRepository.findAll()
                    .stream()
                    .map(s -> new StudentResponseDTO(
                        s.getId(), s.getName(), s.getAge(),
                        s.getCity(), s.getCountry(),
                        s.getMaths(), s.getPhysics(), s.getChemistry()
                    ))
                    .collect(Collectors.toList());
            }
        
            /**
             * Get a single student by name, or throw exception if not found.
             */
            @Override
            public StudentResponseDTO getByName(String name) {
                StudentEntity s = studentRepository.findByName(name)
                    .orElseThrow(() -> new RuntimeException("Student not found"));
        
                return new StudentResponseDTO(
                    s.getId(), s.getName(), s.getAge(),
                    s.getCity(), s.getCountry(),
                    s.getMaths(), s.getPhysics(), s.getChemistry()
                );
            }
        
            /**
             * Update marks for a student by name.
             */
            @Override
            public StudentResponseDTO updateMarks(String name, int maths, int physics, int chemistry) {
                StudentEntity s = studentRepository.findByName(name)
                    .orElseThrow(() -> new RuntimeException("Student not found"));
        
                s.setMaths(maths);
                s.setPhysics(physics);
                s.setChemistry(chemistry);
        
                StudentEntity updated = studentRepository.save(s);
        
                return new StudentResponseDTO(
                    updated.getId(), updated.getName(), updated.getAge(),
                    updated.getCity(), updated.getCountry(),
                    updated.getMaths(), updated.getPhysics(), updated.getChemistry()
                );
            }
        
            /**
             * Delete student by name and return success message.
             */
            @Override
            public String deleteByName(String name) {
                studentRepository.deleteByName(name);
                return "Student deleted successfully!";
            }
        
            /**
             * Business logic: total of all marks
             */
            @Override
            public int getTotalMarksByName(String name) {
                StudentEntity s = studentRepository.findByName(name)
                    .orElseThrow(() -> new RuntimeException("Student not found"));
        
                return s.getMaths() + s.getPhysics() + s.getChemistry();
            }
            }
        
We Can Use Builder Pattern Here
üìå When Can We Use Builder Pattern?
‚û°Ô∏è When creating objects that have many fields, like StudentEntity or StudentResponseDTO.
‚û°Ô∏è Especially useful when:

You don‚Äôt want to pass all values every time.

You want to avoid telescoping constructors.

You want immutability + readability.

üîÅ Two Approaches You Can Use in Service Layer:
1Ô∏è‚É£ Regular Way (Manual Mapping)
        
        StudentEntity student = new StudentEntity();
        student.setName(dto.getName());
        student.setAge(dto.getAge());
        // ...set all fields
        This works ‚Äî but it‚Äôs boilerplate and not scalable in big projects.

2Ô∏è‚É£ ‚úÖ Builder Pattern (Professional Real-Time Usage)
Use Lombok‚Äôs @Builder annotation in your DTO and Entity classes



here‚Äôs the professional, production-level version of the StudentServiceImpl class using the Builder Pattern for both:

StudentEntity (for saving to DB)

StudentResponseDTO (for sending back to frontend)

This version is clean, scalable, and used in real-time enterprise projects.

‚úÖ Final StudentServiceImpl.java (with Builder Pattern used properly)

          package com.myprojects.studentmgmt.service;
          
          import com.myprojects.studentmgmt.dto.StudentDTO;
          import com.myprojects.studentmgmt.dto.StudentResponseDTO;
          import com.myprojects.studentmgmt.entity.StudentEntity;
          import com.myprojects.studentmgmt.repository.StudentRepository;
          
          import org.springframework.beans.factory.annotation.Autowired;
          import org.springframework.stereotype.Service;
          
          import java.util.List;
          import java.util.stream.Collectors;
          
          /**
           * This class contains the actual business logic.
           * Uses Builder Pattern for clean and scalable object creation.
           */
          @Service
          public class StudentServiceImpl implements StudentService {
          
              @Autowired
              private StudentRepository studentRepository;
          
              // Save a new student and return response with generated ID
              @Override
              public StudentResponseDTO save(StudentDTO dto) {
          
                  // ‚úÖ Use Builder to create Entity from DTO
                  StudentEntity student = StudentEntity.builder()
                          .name(dto.getName())
                          .age(dto.getAge())
                          .city(dto.getCity())
                          .country(dto.getCountry())
                          .maths(dto.getMaths())
                          .physics(dto.getPhysics())
                          .chemistry(dto.getChemistry())
                          .build();
          
                  // Save to DB and get the generated ID
                  StudentEntity saved = studentRepository.save(student);
          
                  // ‚úÖ Use Builder to return a clean response DTO
                  return StudentResponseDTO.builder()
                          .id(saved.getId())
                          .name(saved.getName())
                          .age(saved.getAge())
                          .city(saved.getCity())
                          .country(saved.getCountry())
                          .maths(saved.getMaths())
                          .physics(saved.getPhysics())
                          .chemistry(saved.getChemistry())
                          .build();
              }
          
              // Fetch all students
              @Override
              public List<StudentResponseDTO> getAll() {
                  return studentRepository.findAll()
                          .stream()
                          .map(s -> StudentResponseDTO.builder()
                                  .id(s.getId())
                                  .name(s.getName())
                                  .age(s.getAge())
                                  .city(s.getCity())
                                  .country(s.getCountry())
                                  .maths(s.getMaths())
                                  .physics(s.getPhysics())
                                  .chemistry(s.getChemistry())
                                  .build()
                          ).collect(Collectors.toList());
              }
          
              // Fetch by name
              @Override
              public StudentResponseDTO getByName(String name) {
                  StudentEntity s = studentRepository.findByName(name)
                          .orElseThrow(() -> new RuntimeException("Student not found"));
          
                  return StudentResponseDTO.builder()
                          .id(s.getId())
                          .name(s.getName())
                          .age(s.getAge())
                          .city(s.getCity())
                          .country(s.getCountry())
                          .maths(s.getMaths())
                          .physics(s.getPhysics())
                          .chemistry(s.getChemistry())
                          .build();
              }
          
              // Update marks
              @Override
              public StudentResponseDTO updateMarks(String name, int maths, int physics, int chemistry) {
                  StudentEntity s = studentRepository.findByName(name)
                          .orElseThrow(() -> new RuntimeException("Student not found"));
          
                  s.setMaths(maths);
                  s.setPhysics(physics);
                  s.setChemistry(chemistry);
          
                  StudentEntity updated = studentRepository.save(s);
          
                  return StudentResponseDTO.builder()
                          .id(updated.getId())
                          .name(updated.getName())
                          .age(updated.getAge())
                          .city(updated.getCity())
                          .country(updated.getCountry())
                          .maths(updated.getMaths())
                          .physics(updated.getPhysics())
                          .chemistry(updated.getChemistry())
                          .build();
              }
          
              // Delete by name
              @Override
              public String deleteByName(String name) {
                  studentRepository.deleteByName(name);
                  return "Student deleted successfully!";
              }
          
              // Calculate total marks
              @Override
              public int getTotalMarksByName(String name) {
                  StudentEntity s = studentRepository.findByName(name)
                          .orElseThrow(() -> new RuntimeException("Student not found"));
          
                  return s.getMaths() + s.getPhysics() + s.getChemistry();
              }
          }



  üîß Make Sure DTO and Entity Classes Have @Builder!
      In both StudentEntity and StudentResponseDTO, make sure you add:
      
      
      @Builder
      For example:
      
      
      @Data
      @NoArgsConstructor
      @AllArgsConstructor
      @Builder
      public class StudentResponseDTO {
          private Long id;
          private String name;
          private Integer age;
          private String city;
          private String country;
          private Integer maths;
          private Integer physics;
          private Integer chemistry;
      }
‚úÖ Result?
Cleaner

Scalable

Production-grade

You‚Äôre now writing professional-quality backend code üíØ






we're now building the Controller Layer ‚Äî the entry point where the frontend (or Postman/Browser) interacts with our backend using REST APIs.

This is where we handle:

@PostMapping, @GetMapping, etc.

Validations (@Valid)

Path/query variables

Status codes (like 200, 201, 404)

Responses back to frontend




STEP 5: StudentController.java (Clean RESTful Controller)

        
        package com.myprojects.studentmgmt.controller;
        
        import com.myprojects.studentmgmt.dto.StudentDTO;
        import com.myprojects.studentmgmt.dto.StudentResponseDTO;
        import com.myprojects.studentmgmt.service.StudentService;
        
        import org.springframework.beans.factory.annotation.Autowired;
        import org.springframework.http.ResponseEntity;
        import org.springframework.web.bind.annotation.*;
        
        import jakarta.validation.Valid;
        import java.util.List;
        
        /**
         * This controller handles all HTTP requests related to students.
         * It talks to the Service layer (not directly to DB).
         */
        @RestController
        @RequestMapping("/students")  // All routes will be prefixed with /students
        public class StudentController {
        
            @Autowired
            private StudentService studentService;
        
            /**
             * POST /students ‚Üí Create a new student
             * @param studentDTO JSON payload sent by frontend
             * @return Created student with ID
             */
            @PostMapping
            public ResponseEntity<StudentResponseDTO> createStudent(@Valid @RequestBody StudentDTO studentDTO) {
                StudentResponseDTO response = studentService.save(studentDTO);
                return ResponseEntity.status(201).body(response);  // 201 Created
            }
        
            /**
             * GET /students ‚Üí Get all students
             */
            @GetMapping
            public ResponseEntity<List<StudentResponseDTO>> getAllStudents() {
                List<StudentResponseDTO> students = studentService.getAll();
                return ResponseEntity.ok(students);  // 200 OK
            }
        
            /**
             * GET /students/{name} ‚Üí Get student by name
             */
            @GetMapping("/{name}")
            public ResponseEntity<StudentResponseDTO> getStudentByName(@PathVariable String name) {
                StudentResponseDTO student = studentService.getByName(name);
                return ResponseEntity.ok(student);
            }
        
            /**
             * PUT /students/{name}/marks ‚Üí Update marks for a student
             */
            @PutMapping("/{name}/marks")
            public ResponseEntity<StudentResponseDTO> updateStudentMarks(
                    @PathVariable String name,
                    @RequestParam int maths,
                    @RequestParam int physics,
                    @RequestParam int chemistry) {
        
                StudentResponseDTO updated = studentService.updateMarks(name, maths, physics, chemistry);
                return ResponseEntity.ok(updated);
            }
        
            /**
             * DELETE /students/{name} ‚Üí Delete a student by name
             */
            @DeleteMapping("/{name}")
            public ResponseEntity<String> deleteStudent(@PathVariable String name) {
                String message = studentService.deleteByName(name);
                return ResponseEntity.ok(message);
            }
        
            /**
             * GET /students/{name}/total ‚Üí Get total marks
             */
            @GetMapping("/{name}/total")
            public ResponseEntity<Integer> getTotalMarks(@PathVariable String name) {
                int total = studentService.getTotalMarksByName(name);
                return ResponseEntity.ok(total);
            }
        }


